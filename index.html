<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFA Regex Visualizer with Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2196F3;
            --success: #4CAF50;
            --error: #f44336;
            --warning: #ff9800;
            --bg: #f5f5f5;
            --surface: #ffffff;
            --text: #212121;
            --text-secondary: #757575;
            --border: #e0e0e0;
            --highlight: #FF6F00;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, #1976D2 100%);
            color: white;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 0.95em;
            opacity: 0.9;
        }

        .comparison {
            background: white;
            padding: 15px 20px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.95em;
            display: flex;
            gap: 40px;
            align-items: center;
        }

        .regex-display {
            flex: 1;
        }

        .regex-part {
            display: inline-block;
            padding: 2px 8px;
            margin: 0 2px;
            border-radius: 3px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .regex-part.pattern {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .vs {
            color: var(--text-secondary);
            font-weight: 700;
            font-size: 1.1em;
        }

        .string-display {
            flex: 1;
        }

        .string-part {
            display: inline-block;
            padding: 2px 8px;
            margin: 0 2px;
            border-radius: 3px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .string-part.char {
            background: #bbdefb;
            color: #1565c0;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }

        .section {
            background: var(--surface);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid var(--border);
        }

        .section-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary);
            color: var(--primary);
            font-weight: 700;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 0.95em;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-nav {
            background: var(--primary);
            color: white;
            font-size: 0.9em;
            padding: 10px 16px;
        }

        .btn-nav:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-nav:hover:not(:disabled) {
            background: #1976D2;
        }

        .example-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            text-align: left;
            background: white;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .example-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .canvas-container {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            min-height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls-bottom {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .step-info {
            flex: 1;
            background: var(--bg);
            padding: 12px;
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
            color: var(--primary);
        }

        .step-info span {
            font-size: 1.3em;
        }

        .trace-panel {
            background: #f9f9f9;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .trace-item {
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-left: 4px solid var(--primary);
            border-radius: 3px;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .trace-item.current {
            background: #fff9e6;
            border-left-color: var(--highlight);
            font-weight: 600;
        }

        .trace-item.success {
            background: #f1f8e9;
            border-left-color: var(--success);
        }

        .trace-item.error {
            background: #ffebee;
            border-left-color: var(--error);
        }

        .trace-key {
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 3px;
        }

        .trace-value {
            color: var(--text-secondary);
            margin-left: 12px;
            font-family: 'Courier New', monospace;
        }

        .result-box {
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            font-weight: 600;
            font-size: 1.1em;
            text-align: center;
        }

        .result-box.success {
            background: #f1f8e9;
            border: 2px solid var(--success);
            color: #2e7d32;
        }

        .result-box.error {
            background: #ffebee;
            border: 2px solid var(--error);
            color: #c62828;
        }

        .explanation {
            background: #e3f2fd;
            border-left: 4px solid var(--primary);
            padding: 12px;
            border-radius: 4px;
            margin-top: 15px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .play-btn {
            background: var(--primary);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 24px;
            position: absolute;
            bottom: 20px;
            right: 20px;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            transition: all 0.3s;
            z-index: 10;
        }

        .play-btn:hover {
            background: #1976D2;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.5);
        }

        .play-btn.playing {
            background: var(--warning);
        }

        .timeline {
            margin-top: 15px;
            background: var(--bg);
            padding: 10px;
            border-radius: 4px;
        }

        .timeline-bar {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
            cursor: pointer;
        }

        .timeline-progress {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .state-active {
            animation: pulse 0.6s ease-in-out infinite;
        }

        .transition-arrow {
            animation: dash 0.6s linear infinite;
        }

        @keyframes dash {
            0% { stroke-dashoffset: 10; }
            100% { stroke-dashoffset: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé¨ NFA Regex Visualizer - Animated</h1>
            <p class="subtitle">Watch step-by-step how regex patterns match strings using Finite Automata</p>
            <div class="comparison">
                <div class="regex-display">
                    <span class="regex-part pattern">Regex:</span>
                    <span id="regexDisplay" style="font-weight: 600; color: #e91e63;">(a|b)*c</span>
                </div>
                <div class="vs">vs</div>
                <div class="string-display">
                    <span class="string-part char">String:</span>
                    <span id="stringDisplay" style="font-weight: 600; color: #1976D2;">aabc</span>
                </div>
            </div>
        </header>

        <div class="main-layout">
            <!-- Left Panel: Setup & Controls -->
            <div class="section">
                <div class="section-title">‚öôÔ∏è Setup</div>

                <div class="form-group">
                    <label for="pattern">Regex Pattern</label>
                    <input type="text" id="pattern" placeholder="e.g., (a|b)*abb" value="(a|b)*c">
                </div>

                <div class="form-group">
                    <label for="input">Test String</label>
                    <input type="text" id="input" placeholder="e.g., aabb" value="aabc">
                </div>

                <div class="btn-group">
                    <button class="btn-primary" onclick="runSimulation()">‚ñ∂Ô∏è Start</button>
                    <button class="btn-secondary" onclick="resetSimulation()">üîÑ Reset</button>
                </div>

                <div class="explanation" id="explanation"></div>

                <div style="margin-top: 20px;">
                    <strong style="display: block; margin-bottom: 10px;">Quick Examples:</strong>
                    <button class="example-btn" onclick="loadExample('(a|b)*abb', 'aabb')">‚úì (a|b)*abb ‚Üí aabb</button>
                    <button class="example-btn" onclick="loadExample('(a|b)*abb', 'ab')">‚úó (a|b)*abb ‚Üí ab</button>
                    <button class="example-btn" onclick="loadExample('a*b+c?', 'aaabbc')">‚úì a*b+c? ‚Üí aaabbc</button>
                    <button class="example-btn" onclick="loadExample('a*b+c?', 'aaac')">‚úó a*b+c? ‚Üí aaac</button>
                </div>

                <div style="margin-top: 20px; padding: 12px; background: #f0f7ff; border-radius: 4px; font-size: 0.9em; line-height: 1.6;">
                    <strong style="color: var(--primary); display: block; margin-bottom: 8px;">üìö NFA Basics:</strong>
                    <p>üîµ <strong>States</strong> = Circles (positions in automaton)</p>
                    <p>‚û°Ô∏è <strong>Transitions</strong> = Arrows (read char ‚Üí move)</p>
                    <p>üü¢ <strong>Accept State</strong> = Double circle (end state)</p>
                    <p>‚ö° <strong>Epsilon (Œµ)</strong> = Free transition (no char needed)</p>
                </div>
            </div>

            <!-- Right Panel: Main Visualization -->
            <div class="section" style="grid-column: 1 / -1;">
                <div class="section-title">üìä NFA State Graph & Simulation</div>
                
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="nfaCanvas" width="1200" height="500"></canvas>
                    <button class="play-btn" id="playBtn" onclick="toggleAnimation()">‚ñ∂Ô∏è</button>
                </div>

                <div class="controls-bottom">
                    <button class="btn-nav" onclick="previousStep()" id="prevBtn">‚¨ÖÔ∏è Previous</button>
                    <div class="step-info">Step <span id="currentStep">0</span>/<span id="totalSteps">0</span></div>
                    <button class="btn-nav" onclick="nextStep()" id="nextBtn">Next ‚û°Ô∏è</button>
                </div>

                <div class="timeline">
                    <div class="timeline-bar" onclick="seekStep(event)">
                        <div class="timeline-progress" id="timelineProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Bottom: Trace & Results -->
            <div class="section">
                <div class="section-title">üìù Execution Trace</div>
                <div class="trace-panel" id="tracePanel"></div>
                <div id="resultBox"></div>
            </div>

            <div class="section">
                <div class="section-title">üìä Analysis</div>
                <div style="font-size: 0.95em; line-height: 1.8;">
                    <p><strong>NFA Nodes:</strong> <span id="nodeCount">0</span></p>
                    <p><strong>Transitions:</strong> <span id="transCount">0</span></p>
                    <p><strong>Input Length:</strong> <span id="inputLen">0</span></p>
                    <p style="margin-top: 12px; padding: 12px; background: #f5f5f5; border-radius: 4px;">
                        <strong>Time Complexity:</strong> O(n √ó m) where n = input length, m = number of states
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ NFA Engine ============
        class NFANode {
            constructor(id) {
                this.id = id;
                this.transitions = [];
                this.isAccept = false;
            }

            addTransition(char, target) {
                this.transitions.push({ char, target });
            }
        }

        class NFA {
            constructor() {
                this.nodeCounter = 0;
                this.nodes = [];
            }

            createNode() {
                const node = new NFANode(this.nodeCounter++);
                this.nodes.push(node);
                return node;
            }

            createBasic(char) {
                const start = this.createNode();
                const accept = this.createNode();
                accept.isAccept = true;
                start.addTransition(char, accept);
                return { start, accept };
            }

            createUnion(left, right) {
                const start = this.createNode();
                const accept = this.createNode();
                accept.isAccept = true;

                start.addTransition('Œµ', left.start);
                start.addTransition('Œµ', right.start);

                left.accept.transitions = [];
                left.accept.isAccept = false;
                left.accept.addTransition('Œµ', accept);

                right.accept.transitions = [];
                right.accept.isAccept = false;
                right.accept.addTransition('Œµ', accept);

                return { start, accept };
            }

            createConcat(left, right) {
                left.accept.transitions = [];
                left.accept.isAccept = false;
                left.accept.addTransition('Œµ', right.start);

                right.accept.isAccept = true;
                return { start: left.start, accept: right.accept };
            }

            createKleeneStar(inner) {
                const start = this.createNode();
                const accept = this.createNode();
                accept.isAccept = true;

                start.addTransition('Œµ', inner.start);
                start.addTransition('Œµ', accept);

                inner.accept.transitions = [];
                inner.accept.isAccept = false;
                inner.accept.addTransition('Œµ', inner.start);
                inner.accept.addTransition('Œµ', accept);

                return { start, accept };
            }

            createPlus(inner) {
                const start = this.createNode();
                const accept = this.createNode();
                accept.isAccept = true;

                start.addTransition('Œµ', inner.start);

                inner.accept.transitions = [];
                inner.accept.isAccept = false;
                inner.accept.addTransition('Œµ', inner.start);
                inner.accept.addTransition('Œµ', accept);

                return { start, accept };
            }

            createQuestion(inner) {
                const start = this.createNode();
                const accept = this.createNode();
                accept.isAccept = true;

                start.addTransition('Œµ', inner.start);
                start.addTransition('Œµ', accept);

                inner.accept.transitions = [];
                inner.accept.isAccept = false;
                inner.accept.addTransition('Œµ', accept);

                return { start, accept };
            }
        }

        // ============ Parser ============
        class RegexParser {
            constructor(pattern) {
                this.pattern = pattern;
                this.pos = 0;
                this.nfa = new NFA();
            }

            parse() {
                return this.parseUnion();
            }

            parseUnion() {
                let left = this.parseConcat();

                while (this.pos < this.pattern.length && this.pattern[this.pos] === '|') {
                    this.pos++;
                    const right = this.parseConcat();
                    left = this.nfa.createUnion(left, right);
                }

                return left;
            }

            parseConcat() {
                let parts = [];

                while (this.pos < this.pattern.length && this.pattern[this.pos] !== ')' && this.pattern[this.pos] !== '|') {
                    parts.push(this.parseQuantified());
                }

                if (parts.length === 0) return null;
                if (parts.length === 1) return parts[0];

                let result = parts[0];
                for (let i = 1; i < parts.length; i++) {
                    result = this.nfa.createConcat(result, parts[i]);
                }
                return result;
            }

            parseQuantified() {
                let base = this.parseAtom();

                if (this.pos < this.pattern.length) {
                    switch (this.pattern[this.pos]) {
                        case '*':
                            this.pos++;
                            return this.nfa.createKleeneStar(base);
                        case '+':
                            this.pos++;
                            return this.nfa.createPlus(base);
                        case '?':
                            this.pos++;
                            return this.nfa.createQuestion(base);
                    }
                }

                return base;
            }

            parseAtom() {
                if (this.pattern[this.pos] === '(') {
                    this.pos++;
                    const inner = this.parseUnion();
                    if (this.pattern[this.pos] === ')') this.pos++;
                    return inner;
                }

                return this.nfa.createBasic(this.pattern[this.pos++]);
            }
        }

        // ============ Epsilon Closure ============
        function epsilonClosure(nodes) {
            const closure = new Set(nodes);
            const stack = [...nodes];

            while (stack.length > 0) {
                const node = stack.pop();
                for (const { char, target } of node.transitions) {
                    if (char === 'Œµ' && !closure.has(target)) {
                        closure.add(target);
                        stack.push(target);
                    }
                }
            }

            return Array.from(closure);
        }

        // ============ Global State ============
        let currentNFA = null;
        let matchSteps = [];
        let currentStep = 0;
        let isAnimating = false;
        let animationInterval = null;

        // ============ Simulation ============
        function runSimulation() {
            const pattern = document.getElementById('pattern').value.trim();
            const input = document.getElementById('input').value;

            if (!pattern || input === '') {
                alert('Please enter both pattern and input');
                return;
            }

            try {
                const parser = new RegexParser(pattern);
                const result = parser.parse();
                currentNFA = parser.nfa;
                currentNFA.start = result.start;
                currentNFA.accept = result.accept;

                matchSteps = simulateMatching(currentNFA, input);
                currentStep = 0;

                document.getElementById('regexDisplay').textContent = pattern;
                document.getElementById('stringDisplay').textContent = input;
                document.getElementById('inputLen').textContent = input.length;
                document.getElementById('nodeCount').textContent = currentNFA.nodes.length;
                let transCount = 0;
                for (const node of currentNFA.nodes) transCount += node.transitions.length;
                document.getElementById('transCount').textContent = transCount;

                updateAll();
                stopAnimation();
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        function simulateMatching(nfa, input) {
            const steps = [];
            let currentStates = epsilonClosure([nfa.start]);

            steps.push({
                step: 0,
                input: '',
                char: null,
                currentStates: [...currentStates],
                description: 'Start: Compute Œµ-closure'
            });

            for (let i = 0; i < input.length; i++) {
                const char = input[i];
                const nextStates = new Set();

                for (const state of currentStates) {
                    for (const { char: transChar, target } of state.transitions) {
                        if (transChar === char) {
                            nextStates.add(target);
                        }
                    }
                }

                currentStates = epsilonClosure(Array.from(nextStates));

                steps.push({
                    step: i + 1,
                    input: input.substring(0, i + 1),
                    char: char,
                    currentStates: [...currentStates],
                    description: `Read '${char}' and compute Œµ-closure`
                });
            }

            const isMatch = currentStates.some(s => s.isAccept);
            steps[steps.length - 1].isMatch = isMatch;

            return steps;
        }

        // ============ Visualization ============
        function updateAll() {
            updateNFAGraph();
            updateTracePanel();
            updateSteps();
            updateExplanation();
        }

        function updateNFAGraph() {
            const canvas = document.getElementById('nfaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!currentNFA || matchSteps.length === 0) return;

            const step = matchSteps[currentStep];
            drawNFAGraph(ctx, currentNFA, step.currentStates, canvas.width, canvas.height);
        }

        function drawNFAGraph(ctx, nfa, activeStates, width, height) {
            const nodes = nfa.nodes;
            const padding = 60;
            const cols = 5;
            const nodeR = 28;
            const spacingX = (width - 2 * padding) / Math.max(cols - 1, 1);
            const rows = Math.ceil(nodes.length / cols);
            const spacingY = (height - 2 * padding) / Math.max(rows - 1, 1);

            const positions = {};
            for (let i = 0; i < nodes.length; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                positions[nodes[i].id] = {
                    x: padding + col * spacingX,
                    y: padding + row * spacingY
                };
            }

            // Draw transitions
            const drawn = new Set();
            for (const node of nodes) {
                for (const { char, target } of node.transitions) {
                    const key = `${node.id}-${target.id}-${char}`;
                    if (!drawn.has(key)) {
                        drawn.add(key);
                        drawTransition(ctx, positions[node.id], positions[target.id], char, nodeR);
                    }
                }
            }

            // Draw nodes
            for (const node of nodes) {
                const pos = positions[node.id];
                const isActive = activeStates.includes(node);
                const isAccept = node.isAccept;

                // Accept circle
                if (isAccept) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, nodeR + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Main circle
                ctx.fillStyle = isActive ? '#42a5f5' : (isAccept ? '#66bb6a' : '#e0e0e0');
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeR, 0, Math.PI * 2);
                ctx.fill();

                if (isActive) {
                    ctx.strokeStyle = '#1976D2';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, nodeR, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, pos.x, pos.y);
            }
        }

        function drawTransition(ctx, from, to, label, nodeR) {
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const fromX = from.x + nodeR * Math.cos(angle);
            const fromY = from.y + nodeR * Math.sin(angle);
            const toX = to.x - nodeR * Math.cos(angle);
            const toY = to.y - nodeR * Math.sin(angle);

            ctx.strokeStyle = label === 'Œµ' ? '#999' : '#333';
            ctx.lineWidth = label === 'Œµ' ? 1.5 : 2;
            ctx.setLineDash(label === 'Œµ' ? [5, 5] : []);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            ctx.fillStyle = label === 'Œµ' ? '#999' : '#333';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, midX, midY - 12);

            // Arrow
            const arrowSize = 10;
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - arrowSize * Math.cos(angle - Math.PI / 6), toY - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - arrowSize * Math.cos(angle + Math.PI / 6), toY - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function updateTracePanel() {
            const panel = document.getElementById('tracePanel');
            panel.innerHTML = '';

            if (matchSteps.length === 0) return;

            for (let i = 0; i <= currentStep && i < matchSteps.length; i++) {
                const s = matchSteps[i];
                const item = document.createElement('div');
                item.className = 'trace-item';
                if (i === currentStep) item.classList.add('current');
                if (s.isMatch === true) item.classList.add('success');
                if (s.isMatch === false) item.classList.add('error');

                let html = `<div class="trace-key">Step ${s.step}</div>`;
                html += `<div class="trace-value">Input: "${s.input}"</div>`;
                if (s.char) html += `<div class="trace-value">Char: '${s.char}'</div>`;
                html += `<div class="trace-value">States: {${s.currentStates.map(n => n.id).join(', ')}}</div>`;
                if (s.isMatch !== undefined) {
                    html += `<div class="trace-value" style="color: ${s.isMatch ? '#2e7d32' : '#c62828'}; font-weight: 700; margin-top: 5px;">`;
                    html += s.isMatch ? '‚úì MATCH' : '‚úó REJECT';
                    html += '</div>';
                }

                item.innerHTML = html;
                panel.appendChild(item);
            }

            const result = matchSteps[currentStep];
            if (result && result.isMatch !== undefined) {
                const resultBox = document.getElementById('resultBox');
                resultBox.className = `result-box ${result.isMatch ? 'success' : 'error'}`;
                resultBox.textContent = result.isMatch ? '‚úì PATTERN MATCHES!' : '‚úó PATTERN DOES NOT MATCH';
            }

            panel.scrollTop = panel.scrollHeight;
        }

        function updateSteps() {
            document.getElementById('currentStep').textContent = currentStep;
            document.getElementById('totalSteps').textContent = matchSteps.length - 1;
            document.getElementById('timelineProgress').style.width = 
                (currentStep / Math.max(matchSteps.length - 1, 1)) * 100 + '%';

            document.getElementById('prevBtn').disabled = currentStep === 0;
            document.getElementById('nextBtn').disabled = currentStep === matchSteps.length - 1;
        }

        function updateExplanation() {
            const exp = document.getElementById('explanation');
            if (currentStep < matchSteps.length) {
                const step = matchSteps[currentStep];
                exp.innerHTML = `<strong>Current Step:</strong> ${step.description}`;
            }
        }

        function nextStep() {
            if (currentStep < matchSteps.length - 1) {
                currentStep++;
                updateAll();
            }
        }

        function previousStep() {
            if (currentStep > 0) {
                currentStep--;
                updateAll();
            }
        }

        function resetSimulation() {
            currentStep = 0;
            stopAnimation();
            updateAll();
        }

        function seekStep(e) {
            const bar = e.currentTarget;
            const rect = bar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = x / rect.width;
            currentStep = Math.floor(percentage * (matchSteps.length - 1));
            stopAnimation();
            updateAll();
        }

        function toggleAnimation() {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isAnimating = true;
            document.getElementById('playBtn').classList.add('playing');
            document.getElementById('playBtn').textContent = '‚è∏Ô∏è';

            animationInterval = setInterval(() => {
                if (currentStep < matchSteps.length - 1) {
                    currentStep++;
                    updateAll();
                } else {
                    stopAnimation();
                }
            }, 800);
        }

        function stopAnimation() {
            isAnimating = false;
            document.getElementById('playBtn').classList.remove('playing');
            document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è';
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function loadExample(pattern, input) {
            document.getElementById('pattern').value = pattern;
            document.getElementById('input').value = input;
            runSimulation();
        }

        // Initialize
        window.addEventListener('load', () => {
            runSimulation();
        });
    </script>
</body>
</html>